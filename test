#!/usr/bin/python

import time
import thread
import asyncore
from math import fabs
#import daemon
from plugwise import *
import sys
import ConfigParser


MAX_MESSAGE_LENGTH = 1024

DEFAULT_SERIAL_PORT = "/dev/ttyUSB0"

class EventCircle(Circle):
	LastPowerValue = -99999
	Power = -99999
	LastReadAt = 0
	LastUpdate = 0
	Threshhold = 5.0
	Threshhold2 = 1.0
	History = 0.0
	History_until = None

	def __init__(self,mac,stick):
		Circle.__init__(self,mac,stick)
		self.mname = mac
		self.error = 0
		self.online = True
		self.nskips = 0
		self.buffer=[0,0,0,0,0,0,0,0,0,0]
		self.bufferPos = 0
		return
		
	def SetThreshhold(self,Value):
		self.Threshhold = Value

	def StoreToBuffer(self,power):
		#Store history
		self.buffer[self.bufferPos]=power
		self.bufferPos += 1
		if self.bufferPos >= len(self.buffer):
			self.bufferPos = 0
		return

	def GetBufferMaxMin(self):
		copy = []
		copy.extend(self.buffer)
		copy.sort()
		return (copy[-1],copy[0])
		
	def GetChange(self):
		if self.online==False and self.nskips < 30:
			self.nskips += 1
			return None
			
		self.nskips = 0

		try:
			pulse_1s, pulse_8s, pulse_60min = self.get_pulse_counters()
			req_time = time.time()
			corrected_pulses = self.pulse_correction(pulse_1s)
			Power = self.pulses_to_kWs(corrected_pulses)*1000
			
			self.LastReadAt = req_time

			#Time since last update
			tsl = req_time - self.LastUpdate

			#Change since last update.
			change = fabs(Power - self.LastPowerValue)

			AvrgLast2 = (Power + self.Power)/2

			#Change since last check.
			change_check = fabs(Power - self.Power)
			
			
			#Last X seconds man and min values.
			(max,min) = self.GetBufferMaxMin()
			self.StoreToBuffer(Power)

			#Debug
			#if self.mname == "000D6F000072A183":
			#	print (max,min)
			#	print self.buffer
			#	print self.LastPowerValue

			#Fix for poor resolution on low scale
			#if Power < 5.0:
			#	Power = self.AverageLast(3)

		
			if (change > self.Threshhold) or (Power < (min-0.5) ) or (Power > (max+0.5)) or (max == min and self.LastPowerValue != min):
				#False zeros depeding on low load. 
				if Power == 0.0 and self.Power != 0.0:
					self.Power = Power
					return None
				self.LastUpdate = req_time
				Energy = self.GetTotalEnergy(pulse_60min)
				self.LastPowerValue = Power 
				self.error = 0
				self.online = True
				return (req_time,Power,Energy)

			self.Power = Power

		except ValueError:
			self.error +=1
			print "Error reading plug %s  %i times"%(self.mname,self.error)
		except exceptions.TimeoutException:
			self.error +=1
			print "Timeout reading plug %s  %i times"%(self.mname,self.error)

		if self.error == 3:
			self.online = False
			return -1

		#If no change return nothing       	
		return None

	def GetTotalEnergy(self,last_hour_pulses = None):
		#Get count if needed.
		if last_hour_pulses == None:
			_, _, last_hour_pulses = self.get_pulse_counters()
		corrected_pulses = self.pulse_correction(last_hour_pulses,3600)
		Energy = self.pulses_to_kWs(corrected_pulses)

		self.UpdateEnergyHistory()

		return Energy + self.History	

	def UpdateEnergyHistory(self):
		return

class VirtualMeter:
	def __init__(self,Name,Meters):
		self.Name = Name
		self.Meters = {}

		for Meter in Meters:
			#Meter = Meter.strip(" ")
			self.Meters[Meter] = 0.0
			
		self.LastPowerValue = 0.0

		self.Changed = False
		
		return

	def Update(self,Meter,Value):
		if self.Meters.has_key(Meter):
			#if Value == "Offline":
			#	return True
			self.Meters[Meter] = Value
			self.Changed = True
			return True
		return False
	
	def GetChange(self):
		if self.Changed:
			Power = 0.0
			for Meter in self.Meters:
				try:
					Power += self.Meters[Meter]
				except:
					return "Offline"
			self.Changed = False

			if self.LastPowerValue == Power:
				return None
			
			self.LastPowerValue = Power

			return Power
		
		return None
			
		

class PlugwiseEventGuard(Client,Stick):
	
	Plugs = []
	running = True
	lastTotal = 0

	mains = []

	def __init__(self,ConfigFile):			
		self.config = ConfigParser.RawConfigParser(allow_no_value=True)
		self.config.read(ConfigFile)
	
		Name = self.config.get("PlugwiseOptions","Name")
		ip = self.config.get("SensorServer","Address")
		port = self.config.get("SensorServer","Port")
		Server = (ip,int(port))
		device = self.config.get("PlugwiseOptions","PlugwisePort")

		if sys.platform == 'win32':
			device ="COM7"
	
		Stick.__init__(self,device,2)
		Client.__init__(self,Server,"PlugwiseEventGuard")
	
		Sensors = self.config.items("PlugwiseSensors")

		for Sensor in Sensors:
			mac = Sensor[0]
			Plug = EventCircle(mac, self)
			Plug.Name = Sensor[1]
			self.Plugs.append(Plug)
			print "Added sensor: %s" % Plug.Name

		#This is the sum of several sensor feeds. 
		self.VirtualMeters = []

		for i in range(1,30):
			SectionName = "VirtualPlugwiseMeter%i"%i
			
			if self.config.has_section(SectionName):
				items = self.config.items(SectionName)

				for item in items:
					if item[0] == "name":
						Name = item[1]
					elif item[0] == "meters":
						Meters = item[1].replace(" ","").split(",")
						self.VirtualMeters.append(VirtualMeter(Name,Meters))
						print "Added virtual meter: %s" % Name
		return

	def handle_read(self):
		message = self.recv(MAX_MESSAGE_LENGTH)
		#self.log.info('Received message: %s', message)
		print message
		return

	def FindEvents(self):
		Events = []

		#Total power fix
		TotalPower =0
		Count = 0
		TotalTime = 0
		starttime = time.time()		

		for plug in self.Plugs:
			change = plug.GetChange()

			if change == -1:
				Events.append((plug.Name,time.time(),"Offline","",""))
				continue

			if change == None:
				continue


			Events.append((plug.Name,change[0],change[1],change[2]))
			
			for VirtualMeter in self.VirtualMeters:
				VirtualMeter.Update(plug.Name,change[1])
				

		for VirtualMeter in self.VirtualMeters:
			change = VirtualMeter.GetChange()
			if change == None:
				continue
			Events.append((VirtualMeter.Name,time.time(),change,"0","0"))
		
		#Print the time it took
		looptime = time.time() - starttime
		if looptime > 2:
			print "WARNING! Loop time %f s"	% (looptime)	
		
		return Events

	def PollAndSendEvents(self,delay):

		while(self.running):
			start = time.time()
			Events = self.FindEvents()
	
			for event in Events:
				#print event
				self.SendEventDirectToSocket(event[1],"METER_EVENT",event[0],str(event[2]))
				
					
			wait_time = delay - (time.time() - start)
			#print wait_time
			if wait_time > 0:
				time.sleep(wait_time)
			#print "tick!"
		
		return

	
if __name__ == '__main__':

	try:
		ConfigFile = sys.argv[1]
	except:
		ConfigFile = ""

	if sys.platform == 'win32':
		ConfigFile = r"G:\Anton\Dropbox\01 Projekt\Royal Sea port\Aktiva huset - Visualiseringar\Signals and server scripts\SVN\EventSystem\SensorServer\Drivers\Red_kit.cfg"

	try:
		f = open(ConfigFile,"r")
		f.close()
	except:
		print "No valid config file supplied as argument!"

	g = PlugwiseEventGuard(ConfigFile)
	g.say(g.CurrentTime(time.time()) + '\tLOGICAL EVENT\tPlugwise event guard\tStarted\n\r')

	#Start new thread for server connunication
	thread.start_new_thread(asyncore.loop,())

	g.PollAndSendEvents(2)


	
	
